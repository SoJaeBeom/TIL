## 정렬 알고리즘
- 목록 안에 저장된 요소들을 특정한 순서대로 재배치하는 알고리즘이다.
- 정렬을 하는 이유
  - 효율적인 알고리즘을 사용하기 위해
  - 사람이 읽기 편하도록
- 입력 데이터는 일반적으로 배열 같은 데이터 구조에 저장
  - 아무 위치로의 임의 접근을 허용
  - 연결 리스트를 사용하면 처음 혹은 끝부터 차례대로 훑어야함
- 흔히 사용하는 순서
  - 숫자 순서
  - 사전 순서
  - ASCII Table
- 정렬 방향
  - 오름 차순
  - 내림 차순
- 다양한 정렬 알고리즘이 있음
  - 시간 복잡도 차이
  - 메모리 사용량 차이
  - 안정성 차이
  - 직렬 vs 병렬 차이

### 정렬 알고리즘의 안정성
- 똑같은 키를 가진 데이터들의 순서가 바뀌지 않느냐 여부

### 대표적인 정렬 알고리즘
- 버블 정렬
- 선택 정렬
- 삽입 정렬
- 퀵 정렬
- 병합 정렬
- 힙 정렬
---
### 1. 버블 정렬
  - 이웃 요소 둘을 비교해서 올바른 순서로 고치는 과정을 반복
  - 한번 목록을 순회할 때마다 가장 큰 값이 제일 위로 올라감
  - 시간 복잡도 : O(N^2)
  - 공간 복잡도 : O(1)
  - 안정성
    - 값이 같은 경우 순서를 바꾸지 않음
    - 정렬 후에도 순서가 유지됨

### 2. 선택 정렬
  - 최솟값을 찾아 선택
  - 시간 복잡도, 공간 복잡도 : 버블 정렬과 동일
  - 안정성 : 보장 안됨

### 3. 삽입 정렬
  - 목록을 차례대로 훑으면서 다음 과정을 반복
    - 현재 위치의 요소를 뽑음
    - 과거에 방문했던 요소들 중에 어디 사이에 넣어야 정렬이 유지되는지 판단
    - 그 위치에 삽입
    - 삽입으로 인해 다른 요소들을 오른쪽으로 shift할 수도 있음
  - 시간 복잡도, 공간 복잡도 : 버블 정렬과 동일
  - 안정성 : 보장 됨

### 4. 퀵 정렬
  - 일반적으로 가장 빠름
  - 분할 정복 알고리즘
    - 모든 요소를 방문함
  - 어떤 값(pivot)을 기준으로 목록을 하위 목록으로 2개로 나눔
    - 목록을 나누는 기준은 pivot보다 작냐/크냐
    - 이 과정을 재귀적으로 반복
    - 재귀 단계가 깊어질 때마다 새로운 pivot값을 뽑음
    - 시간 복잡도
      - 평균 : O(NlogN)
      - 최악 : O(N^2)
    - 공간 복잡도
      - 재귀적으로 함수를 호출
      - 실제 원본 배열을 고침 : O(1)
      - 함수 호출 깊이만큼 스택 메모리 사용
        - O(logN)
        - 스택 메모리라 할당/해제가 매우 빠름

### 5. 병합 정렬
  - 이미 정렬된 두 배열 합치기
  - 시간 복잡도 : O(N)
  - 공간 복잡도 : 배열 하나를 더 만들었음 -> O(N)

### 6. 힙 정렬
  - 트리에 기반한 자료 구조
  - 힙을 사용하는 정렬 알고리즘
    - 부모의 키가 자식의 키와 같거나 큼
    