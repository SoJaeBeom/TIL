# 메모리

- CPU는 메모리에 올라와 있는 프로그램의 명령어들을 실행한다.

## 메모리 계층

- 메모리 계층은 위에서 부터 레지스터, 캐시, 메모리, 저장장치 순서로 구성되어 있다.
  - 레지스터
    - CPU안에 있는 작은 메모리, 휘발성, 속도가 빠르다, 기억 용량이 가장 적다.
  - 캐시
    - L1, L2 캐시를 지칭한다. 휘발성, 속도 빠르다. 기억 용량이 적다.
  - 주기억 장치
    - RAM을 가리킨다. 휘발성, 속도 보통, 기억 용량이 보통이다.
  - 보조기억장치
    - HDD, SDD를 말한다. 휘발성, 속도 낮음, 기억 용량이 많다.
- 램은 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요 시마다 CPU에 빠르게 전달하는 역할을 한다.
- 계층 위로 올라갈수록 가격을 비싸지는데 용량은 작아지고 속도는 빨라진다.
- 계층이 있는 이유는 경제성과 캐시 때문이다.

### 캐시

- 데이터를 미리 복사해 놓는 임시 저장소이다.
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리다.
- 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있다.
- 메모리와 CPU 사이의 속도 차이가 너무 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 차이를 해결한다.
- 속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 한다.

#### 지역성의 원리

1. 시간 지역성

- 최근 사용한 데이터에 다시 접근하려는 특성을 말한다.

2. 공간 지역성

- 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성을 말한다.

### 캐시히트와 캐시미스

- 캐시에서 원하는 데이터를 찾았다면 캐시히트라고 한다.
- 해당 데이터가 캐시에 없다면 주 메모리로 가서 데이터를 찾아오는 것을 캐시미스라고 한다.
- 캐시히트의 경우 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠르다.
- 캐시미스가 발생되면 시스템 버스를 기반으로 메모리에서 가져오기 때문에 느리다.

#### 캐시 매핑

- 캐시가 히트뒤기 위해 매핑하는 방법이다.
- CPU의 레지스터와 주 메모리간에 데이터를 주고받을 때를 기반으로 한다.

1. 직접 매핑

- 메모리가 1~100이 있고 캐시가 1~10이 있다면 1:1~10, 2:1~20... 이런 식으로 매핑하는 것이다.
- 처리가 빠르지만 충돌 발생이 잦다.

2. 연관 매핑

- 순서를 일치시키지 않고 관련 있는 캐시와 메모리를 매핑한다.
- 충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느리다.

3. 집합 연관 매핑

- 직접 매핑과 연관 매핑을 합쳐 놓은 것이다.
- 순서는 일치시키지만 집합을 둬서 저장하며 블록화되어 있기 때문에 검색은 좀 더 효율적이다.

#### 웹 브라우저의 캐시

- 사용자의 커스텀한 정보나 인증 모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰인다.

1. 쿠키

- 만료기한이 있는 키-값 저장소이다.
- same site 옵션을 strict로 설정하지 않았을 경우 다른 도메인에서 요청했을 때 자동 전송된다.
- 쿠키를 설정할 때는 document.cookie로 쿠키를 볼 수 없게 httponly 옵션을 거는 것이 중요하다.
- 클라이언트 또는 서버에서 만료기한 등을 정할 수 있는데 보통 서버에서 만료기한을 정한다.

2. 로컬 스토리지

- 만료기한이 없는 키-값 저장소이다.
- 웹 브라우저를 닫아도 유지되고 도메인 단위로 저장, 생성된다.
- 클라이언트에서만 수정 가능하다.

3. 세션 스토리지

- 만료기한이 없는 키-값 저장소이다.
- 탭 단위로 세션 스토리지를 생성하며 탭을 닫을 때 해당 데이터가 삭제된다.
- 클라이언트에서만 수정 가능하다.

#### 테이터베이스의 캐싱 계층

- 데이터베이스 시스템을 구축할 때도 메인 데이터베이스 위에 레디스 데이터 베이스 계층을 캐싱 계층으로 둬서 성능을 향상시킨다.

## 메모리 관리

- 운영체제의 대표적인 할 일 중 하나가 메모리 관리다.

### 가상 메모리

- 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것이다.
- 가상 주소는 메모리관리장치에 의해 실제 주소로 변환된다.
- 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 페이지 테이블로 관리된다.

> TLB
>
> - 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시이다.
> - 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 해 속도를 향상시킬 수 있는 캐시 계층이다.

#### 스와핑

- 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고 사용하지 않으면 다시 하드 디스크로 내림을 반복하여 RAM을 효과적으로 관리하는 것이다.

#### 페이지 폴트

- 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생한다.

### 스레싱

- 메모리의 페이지 폴트율이 높은 것을 의미한다.
- 컴퓨터의 성능 저하를 초래한다.
- 메모리에 너무 많은 프로세스가 동시에 올라가게 되면 스와핑이 많이 일어나서 스레싱이 발생한다.
- 해결 방법은 메모리를 늘리거나, SDD를 사용하는 방법, 작업 세트, PFF 방법이 있다.

#### 작업 세트

- 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하는 것이다.
- 미리 메모리에 로드하면 탐색에 드는 비용을 줄일 수 있고 스와핑ㄹ 또한 줄일 수 있다.

#### PFF

- 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법이다.

### 메모리 할당

- 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당한다.
- 연속 할당과 불연속 할당으로 나뉜다.

#### 연속 할당

- 메모리에 연속적으로 공간을 할당하는 것이다.

1. 고정 분할 방식

- 메모리를 미리 나누어 관리하는 방식이다.
- 메모리가 미리 나뉘어 있기 때문에 융통성이 없다.
- 내부 단편화가 발생한다.

2. 가변 분할 방식

- 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용한다.
- 내부 단편화는 발생하지 않고 외부 단편화는 발생할 수 있다.
- 최초적합, 최적적합, 최악적합이 있다.

> 내부 단편화
>
> - 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 많이 발생하는 현상이다.

> 외부 단편화
>
> - 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 많이 발생하는 현상이다.

#### 불연속 할당

- 메모리를 연속적으로 할당하지 않는다.

##### 페이징

- 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다.
- 홀의 크기가 균일하지 않은 문제가 없어지지만 주소 변환이 복잡해진다.

##### 세그멘테이션

- 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식이다.
- 공유와 보안 측면에서 좋으며 홀 크기가 균일하지 않은 문제가 발생된다.

##### 페이지드 세그멘테이션

- 공유나 보안을 의미 단위의 세그먼트로 나누고 물리적 메모리는 페이지로 나누는 것이다.

### 페이지 교체 알고리즘

- 메모리는 한정되어 있기 때문에 스와핑이 많이 일어난다.

#### 오프라인 알고리즘

- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이다.

#### FIFO

- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법이다.

#### LRU

- 참조가 가장 오래된 페이지를 바꾼다.
- 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 한다.
- LRU 구현을 프로그래밍으로 구현할 때 해시 테이블과 이중 연결 리스트 자료 구조를 사용한다.
- 해시 테이블은 이중 연결 리스트에서 빠르게 찾을 수 있도록 쓰고 이중 연결 리스트는 한정된 메모리를 나타낸다.

#### LFU

- 가장 참조 횟수가 적은 페이지를 교체한다.
- 많이 사용되지 않은 것을 교체하는 것이다.
