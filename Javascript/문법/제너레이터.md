## 제너레이터

- 이터러블이며 동시에 이터레이터다.
- 이터레이터를 리턴하는 함수이다.(async가 Promise를 리턴하는 함수듯이, 제너레이터는 이터레이터를 리턴하는 함수다.)
- 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 구현할 수 있다.

- 제너레이터 함수는 일반 함수와는 다른 독특한 동작을 한다.
- 제너레이터 함수는 일반 함수처럼 함수의 코드 블록을 한 번에 실행하지 않고 함수 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재시작할 수 있는 특수한 함수이다.

### 제너레이터 방식(function 옆에 \*을 붙인다.)

```js
const range = function* () {
  //제너레이터 지정해주면 얘 자체가 이터레이터를 반환해준다.
  let i = 1
  while (true) {
    //어차피 안에 yield에 의해서 코드가 멈추니 무한루프 해줘서 원할때 진행을 이어나갈수 있게 한다
    if (i <= 5) yield ++i
    /* yield를 만나면 일시정지되고, 값을 건네준다. 그리고 for..of에 의해서 next()
                    가 호출되면 함수 실행을 이어 나간다. 
                    이터러블 일경우 next()를 정의하고 안에 리턴값을 {value:,donw:}을 일일히
                    정의 해줘야 하는데, 제너레이터는 yield로 퉁칠수 있다. */ else
      return
  }
}

for (let i of range()) {
  console.log(i) // 1,2,3,4,5
}
```

```js
// 제너레이터 함수 선언식
function* genDecFunc() {
  yield 1
}
let generatorObj = genDecFunc() // 제너레이터 함수 실행 결과 반환된 제너레이터 객체를 변수에 넣어 사용한다.

// 제너레이터 함수 표현식
const genExpFunc = function* () {
  yield 1
}
generatorObj = genExpFunc()

// 제너레이터 메소드 식
const obj = {
  *generatorObjMethod() {
    yield 1
  },
}
generatorObj = obj.generatorObjMethod()

// 제너레이터 클래스 메소드 식
class MyClass {
  *generatorClsMethod() {
    yield 1
  }
}
const myClass = new MyClass()
generatorObj = myClass.generatorClsMethod()
```
