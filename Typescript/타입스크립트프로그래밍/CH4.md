# 함수

## 함수 선언과 호출

- 자바스크립트에서 함수는 일급 객체다.
  - 객체를 다루듯이 함수를 변수에 할당한다.
  - 함수를 다른 함수로 전달한다.
  - 함수에서 함수를 반환한다.
  - 객체와 프로토타입에 할당한다.
  - 함수에 프로퍼티를 기록한다.
  - 함수에 기록된 프로퍼티를 읽는다.
- 함수 매개변수의 타입은 명시적으로 정의한다.
- 반환타입은 자동으로 추론하지만 원하면 명시할 수 있다.
  - 타입스크립트가 반환 타입을 추론하도록 하는게 보통이다.

### 타입스크립트의 함수 선언 방식

- 이름을 붙인 함수

```ts
function greet(name: string) {
  return name;
}
```

- 함수 표현식

```ts
let greet2 = function (name: string) {
  return name;
};
```

- 화살표 함수 표현식

```ts
let greet3 = (name: string) => {
  return name;
};
```

- 단축형 화살표 함수 표현식

```ts
let greet4 = (name: string) => return name;
```

- 함수 생성자

```ts
let greet5 = new Function('name', name);

// 함수 생성자는 타입이 Function이다.
// Function 타입은 Function이름 뒤에 ()를 붙여서 호출할 수 있는 객체로 Function.prototype의 모든 프로토타입 메서드를 포함한다.
// 매개변수 타입과 반환타입을 지정하지 않았으므로 어떤 인수를 건네서도 호출을 할수 있기때문에 문제가 발생해도 처리할 수가없다.
```

### 선택적 매개변수와 기본 매개변수

- 함수에서도 ?를 이용해 선택적 매개변수를 지정할 수 있다.
- 필수 매개변수를 먼저 지정하고 선택적 매개변수를 뒤에 추가한다.
- 매개변수에 기본값을 지정할 수 있다.
- 호출자가 해당 매개변수에 값을 전달하지 않아도 되므로 매개변수를 선택적으로 만드는 것과 같다.

### 나머지 매개변수

- 인수를 여러개 받는 함수라면 그 목록을 배열 형태로 건넬 수도 있다.
- 가변 인자가 필요할 때 자바스크립트는 arguments객체를 통해 가능하다.
- arguments는 일종의 배열(순수한 배열은 아님)이므로 배열로 변환을 한 후에 .reduce 같은 내장 기능을 사용할 수 있다.
- 안전한 타입의 가변 인수 함수를 만들기 위해 나머지 매개변수를 사용할 수 있다.

### call, apply, bind

- 괄호로 함수를 호출할 수 있다.
- apply는 함수 안에서 값을 this로 한정하며 두번째 인수를 펼쳐 함수에 매개변수로 전달한다.
- call은 인수를 펼쳐 전달하지 않고 순서대로 전달한다.
- bind는 this인수를 함수의 인수 목록으로 한정한다.

### this의 타입

- this의 값은 함수를 어떻게 호출했는지에 따라 달라진다.

### 제너레이터 함수

- 여러개의 값을 생성하는 편리한 기능을 제공한다.

### 반복자

- 반복자와 제너레이터는 상생관계다.
- 제너레이터로 값의 스트림을 생성할 수 있고 반복자로 생성된 값을 소비할 수 있기 때문이다.

> 이터러블
>
> - Symbol.iterator라는 프로퍼티(반복자를 반환하는 함수)를 가진 모든 객체

> 반복자
>
> - next라는 메서드를 정의한 객체

- Symbol.iterator와 next를 구현하는 객체를 만들어 반복자나 이터러블을 직접 정의할 수 있다.

### 호출 시그니처

- Function은 모든 함수의 타입을 뜻할 뿐이며 그것이 가리키는 특정함수와 타입과 관련된 정보는 아무것도 알려주지 않는다.

```ts
(a: number, b: number) => number;

// 타입스크립트의 함수 타입문법으로 호출 시그니처, 타입 시그니처라 부른다.
```

- 함수 호출 시그니처는 타입 수준 코드, 값이 아닌 타입 정보만 포함한다.
- 함수 호출 시그니처는 바디를 포함하지 않아 타입스크립트가 타입을 추론할 수 없으므로 반환 타입을 명시해야한다.

> 타입 수준 코드
>
> - 타입과 타입 연산자를 포함하는 코드를 의미한다.
>
> 값 수준 코드
>
> - 그 밖의 모든 것을 가리킨다.

### 문맥적 타입화

- 함수의 매개변수 타입을 명시하지 않아도 되는 이유는 문맥적 타입화라는 타입스크립트의 타입 추론 기능 때문이다.
- 함수 선언을 인라인으로 제공하면 인수로 전달하는 함수의 타입을 명시할 필요가 없다.

### 오버로드된 함수 타입

> 오버로드된 함수
>
> - 호출 시그니처가 여러 개인 함수

- 자바스크립트는 동적 언어이므로 어떤 함수를 호출하는 방법이 여러가지다.
- 인수 입력 타입에 따라 반환 타입이 달라질떄도 있다.

> 오버로드 시그니처는 구체적으로 유지하자
>
> - 오버로드된 함수 타입을 선언할 때는 각 오버로드 시그니처를 구현의 시그니처에 할당할 수 있어야 한다.
> - 오버로드를 할당할 수 있는 범위에서 구현의 시그니처를 일반화할 수 있다.
> - 오버로드를 사용할 때는 함수를 쉽게 구현할 수 있도록 가능한 시그니처를 특정하는 것이 좋다.

### 다형성

- 어떤 타입을 사용할지 미리 알 수 없는 상황에서는 함수를 특정 타입으로 제한하기 어렵다.

```ts
let names = [
  { firstName: 'beth' },
  { firstName: 'caitlyn' },
  { firstName: 'xin' },
];

let result = filter(names, (_) => _.firstName.startsWith('b'));

result[0].firstName; // 에러 'firstName' 프로퍼티는 object타입에 존재하지 않음

// object는 객체의 실제 형태에 대해서는 어떤 정보도 알려주지 않았다.
// 따라서 배열에 저장된 객체의 프로퍼티에 접근하려 시도하면 타입스크립트가 에러를 발생시킨다.
```

> 제네릭 타입 매개변수
>
> - 여러 장소에 타입 수준의 제한을 적용할 때 사용하는 플레이스홀더 타입.
> - 다형성 타입 매개변수라고도 부른다.

```ts
type Filter = {
  <T>(array: T[], f: (item: T) => boolean): T[];
};

// 이 타입이 무엇인지 지금은 알수 없으니 filter를 호출할 때마다 타입스크립트가 타입을 추론해라 라는 뜻이다.
```

- 꺽쇠 괄호의 위치에 기초하여 제네릭 T를 적절한 구체 타입으로 한정한다.
- 어떤 인수를 넣어 호출하느냐에 따라 T를 어떤 구체 타입으로 한정할지 정한다.
- 필요하면 꺽쇠괄호 안에 제네릭 타입 매개변수 여러 개를 콤마로 구분해 선언할 수 있다.
- 타입스크립트는 전달된 인수의 타입을 이용해 제네릭을 어떤 타입으로 한정할지 추론한다.
- 타입 별칭, 클래스, 인터페이스에서도 제네릭 타입을 사용할 수 있다.
- 제네릭은 코드를 일반화하고, 재사용성을 높이고, 간결하게 유지하는 데 도움을 준다.

#### 언제 제네릭 타입이 한정되는가?

- 제네릭 타입의 선언 위치에 따라 타입의 범위뿐 아니라 타입스크립트가 제네릭 타입을 언제 구체 타입으로 한정하는지도 결정된다.
- 타입스크립트는 제네릭 타입을 사용하는 순간에 제네릭과 구체 타입을 한정한다.
- 제네릭을 사용할 때
  - 함수에서는 함수를 호출할때
  - 클래스라면 클래스를 인스턴스화할때
  - 타입 별칭과 인터페이스에서는 사용하거나 구현할때를 가리킨다.

#### 제네릭 타입 추론

- 타입스크립트는 제네릭 함수의 인수에만 의지하여 제네릭 타입을 추론하는데 인수가 아무것도 없으니 기본적으로 T를 {}로 간주한다.
